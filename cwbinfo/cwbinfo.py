import pickle
import re

from math import sin, cos, sqrt, atan2, radians
from pathlib import Path
from tqdm import tqdm
from datetime import datetime, timedelta, date
from pprint import pprint as pp

class CWBInfo:

    def __init__(self):
        self.station_data = None
        self.weather_data = None
        self.ave = {}
        self.MAX = {}
        self.MIN = {}

    def load_station_data_from_pickle(self, path):
        """ 
        load station data from pre-process station pickle file.(generated by process_weather_data.py)
        <station_id, <ch_name, en_name, city, address, lat, lon, alt, station_type, setup_date> >
        """
        path = Path(path)
        self.station_data = pickle.load(Path(path).open('rb'))

    def load_weather_data_from_pickle(self, path, transform=True, missingValue=True):
        """
        (optional)
        load weather pickle data crawled by crawl_weather_data.py.
        <station_id, <datetime, <ObsHour, StnPres, SeaPres, Temp, TdDewPnt, RH, WS, WD, WSGust, WDGust, Precp, PrecpHours, SunShine, GloblRad, Visb, UVI, CloudAmount > >  >
        """
        path = Path(path)
        self.weather_data = pickle.load(Path(path).open('rb'))
        if(transform == True):
            self.transform_to_float_and_calculate_ave()
        if(missingValue == True):
            self.process_missing_value()

    def transform_to_float_and_calculate_ave(self):
        print('=========== Transform Value from String to Float ===========')
        error_state = [None, 'V', 'v', 'X', 'x', 'T', 't', '/', '']
        for st_id, st in tqdm(self.weather_data.items()):
            total = 0
            ave = [0.0 for _ in range(17)]
            for day, d in st.items():
                for hour, row in d.items():
                    for index, val in enumerate(row):
                        if(val not in error_state):
                            try:
                                self.weather_data[st_id][day][hour][index] = float(self.weather_data[st_id][day][hour][index])
                                ave[index] += float(val)
                            except Exception as ex:
                                pp(ex)
                                pp(self.weather_data[st_id][day][hour][index])
                    total += 1
            self.ave[st_id] = [ val/total for val in ave]

    def get_nearest_weather_station(self, lat, lon, accept_type=['46','C0']):
        """
        return id of nearest station within accept_type
        """
        dis = [ [k, self.latlon_distance(lat, lon, float(v['lat']), float(v['lon']))] for k, v in self.station_data.items() ]
        dis.sort(key=lambda elem: elem[1])
        return dis[0][0]

    def get_stations(self):
        """
        return all staion data
        """
        return self.station_data

    def get_meteo_data_by_feature_index(self, st_id, st_time, ed_time, feature_index=[3, 1, 5, 6, 7]):
        """
        3:Temp; 1:StnPres; 5:HUMD, 6:WS, 7:WD
        """
        d = self.weather_data[st_id]
        ret = [[] for _ in feature_index]
        with tqdm(total=(ed_time-st_time)/timedelta(days=1)) as pbar:
            while st_time != ed_time:
                try:
                    _d = d[st_time]
                    for t in range(1, 24):
                        for k, index in enumerate(feature_index):
                            ret[k].append(_d[t][index])
                except Exception as ex:
                    print(ex)
                finally:
                    st_time += timedelta(days=1)
                    pbar.update(1)
        return ret


    def get_meteo_data_in_period(self, st_id, st_time, ed_time):
        d = self.weather_data[st_id]
        ret = [] 
        with tqdm(total=(ed_time-st_time)/timedelta(days=1)) as pbar:
            while st_time != ed_time:
                try:
                    ret.append(d[st_time])
                except Exception as ex:
                    print(ex)
                finally:
                    st_time += timedelta(days=1)
                    pbar.update(1)
        return ret

    def process_missing_value(self):
        print('=========== Filling Missing Value ===========')
        error_state = [None, 'V', 'v', 'X', 'x', '/', '']
        micro_state = ['T', 't']
        for st_id, st in tqdm(self.weather_data.items()):
            total = 0
            MAX = [- 10 ** 10 for _ in range(17)]
            MIN = [10 ** 10 for _ in range(17)]
            for day, d in st.items():
                for hour, row in d.items():
                    for index, val in enumerate(row):
                        if val in micro_state:
                            try:
                                self.weather_data[st_id][day][hour][index] = 0.0 
                            except Exception as ex:
                                pp(ex)
                                pp(self.weather_data[st_id][day][hour][index])
                        elif val in error_state:
                            try:
                                self.weather_data[st_id][day][hour][index] = self.ave[st_id][index] 
                            except Exception as ex:
                                pp(ex)
                                pp(self.weather_data[st_id][day][hour][index])
                        MAX[index] = max(MAX[index], self.weather_data[st_id][day][hour][index])
                        MIN[index] = min(MIN[index], self.weather_data[st_id][day][hour][index])
            self.MAX[st_id] = MAX
            self.MIN[st_id] = MIN

    def normalize_data(self):
        # normalize to range of [0, 1]
        print('========== Normalizing Data to range of [0, 1] ==========')
        for st_id, st in tqdm(self.weather_data.items()):
            for day, d in st.items():
                for hour, row in d.items():
                    for index, val in enumerate(row): 
                        try: 
                            self.weather_data[st_id][day][hour][index] = (self.weather_data[st_id][day][hour][index] - self.MIN[st_id][index]) / (self.MAX[st_id][index] - self.MIN[st_id][index])
                        except:
                            self.weather_data[st_id][day][hour][index] = 0.0

    @staticmethod
    def latlon_distance(lat1:float, lon1:float, lat2:float, lon2:float) -> float:
        # Ref: https://www.movable-type.co.uk/scripts/latlong.html 
        R = 6371.0
        phi1 = radians(lat1)
        phi2 = radians(lat2)
        phi = radians(lat2-lat1)
        sigma = radians(lon2-lon1)

        a = sin(phi/2)**2 + cos(phi1) * cos(phi2) * sin(sigma/2)**2
        c = 2 * atan2(sqrt(a), sqrt(1-a))

        return R * c

def save_model(obj, path):
    path = Path(path)
    if not path.parent.exists():
        path.parent.mkdir() 
    path.write_bytes(pickle.dumps(obj))

def load_model(path):
    path = Path(path)
    return pickle.load(path.open('rb'))

if __name__ == "__main__":
    #  CWB = CWBInfo()
    #  CWB.load_station_data_from_pickle('../pickle_data/stations_info.pickle')
    #  CWB.load_weather_data_from_pickle('../pickle_data/weather_data.pickle', transform=True, missingValue=True)
    #  CWB.normalize_data()
    #  save_model(CWB, '../pickle_data/104_CWB_wo_normalize.pickle')
    CWB = load_model('../pickle_data/104_CWB_wo_normalize.pickle')

    #st = CWB.get_nearest_weather_station(24.32323, 121.456465)
    st = CWB.get_nearest_weather_station(24.79323, 121.086465)
    d = CWB.get_meteo_data_by_feature_index(st, date(2015, 1, 1), date(2015, 1, 3))
    pp(d)
    #print(EPA.get_data_by_station_name(st))
    print(st)
    #d = CWB.get_meteo_data_in_period(st, date(2015, 1, 1), date(2015, 2, 1))

    #pp(d)
